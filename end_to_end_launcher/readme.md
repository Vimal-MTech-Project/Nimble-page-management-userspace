## End-to-End Benchmarks
The end-to-end benchmarks used here are developed by Zi Yan et al. as part of the paper presented in ASPLOS'19 titled "Nimble Page Management For Tiered Memory Systems."

* Please consider reading [this](https://normal.zone/blog/2019-01-27-nimble-page-management/#user-application-launcher) article to learn more about the scripts in this directory.

* We modify some of the scripts to adapt to our setup and collect extra data(like the number of reads/writes to Optane media), which are important in our case.

### Information about files/scripts:

* `run_all.sh`: This script is the starting point of benchmarks.
  * You may change some of the variables defined in this script as needed. The meaning of such variables should be clear from the code comments
  * If not, please refer to [this](https://normal.zone/blog/2019-01-27-nimble-page-management/#user-application-launcher) article
* `run_bench.sh`: This file is run by `run_all.sh`. It prepares command line for `launcher` and runs it.
* `create_die_stacked_mem.sh`: Creates a control group that limits the memory allocation from different NUMA nodes to the application as needed. It is Used by `run_bench.sh`. As a user, you don't have to deal with this directly.
* `launcher.c`: This program runs a benchmark as a child process. It periodically invokes a kernel syscall which performs victim page selection from child memory pages and migrates those pages to either slow or fast memory node as needed. This program also collects statistics about the child process and prints the results.
* `extract_data_to_csv.sh`: Used to generate CSV file containing benchmark result data.
* `generate_plots.py`: This script generates plots from CSV file generated by `extract_data_to_csv.sh`.

### Here are a few steps to help you get started with running benchmarks:

* You need to build and install the kernel provided [here](https://github.com/Vimal-MTech-Project/rpdaa-pmem-page-migration-optimization-kernel.git)

* Enable cgroup `V2` support by adding `systemd.unified_cgroup_hierarchy=1` to your kernel boot parameters.

* Configure Optane DIMM in Device-DAX mode. Hotplug this Optane region as a System RAM using `daxctl` utility. For example, use command similar to following:
  * `daxctl reconfigure-device dax5.0 --mode=system-ram`

    The value `dax5.0` is setup dependent and might vary in your setup.

* Make sure you have `libipmctl` installed. The launcher program uses it to collect the number of reads/writes to the Optane media.

* run `make` command to create `launcher` binary.

* `run_all.sh` is a starting point of benchmarks. Some of the variables in it needs to be changed as per your setup.
  * `sudo run_all.sh`

* Once `run_all.sh` finishes executing, the stats will be stored in `results-*` folder.

* Use `extract_data_to_csv.sh` script to generate a CSV file containing the result.
  * `extract_data_to_csv.sh [result directory] > result.csv`

* You may want to generate plots using `generate_plots.py`, which accepts the CSV file generated using `extract_data_to_csv.sh`
  * `python3 generate_plots.py result.csv`
  * The above command will generate three plots showing execution time, a number of reads, and writes to PMEM under different page migration schemes for various benchmarks.
